{"posts":[{"title":"CSP-S2周末刷题班（第一场）","content":"A 小YY有一个nn行mm列的方格纸，每一个格子上都写有一个小写英文字母。 小YY会将每一行单独取出来，将这一行的字符从左到右拼起来组成一个单词，并将这个单词加入小YY的字典。 类似的，小YY也会将每一列单独取出来，将这一列的字符从上到下拼起来组成一个单词，并将这个单词加入字典。 现在，小YY想知道，他的字典里有多少本质不同的单词？两个单词本质相同当且仅当他们长度相同且对应位置都相同。 方格纸上的字母可能会有修改，具体来说，有QQ次修改，每次将第xx行第yy列的字符修改为chch, 你需要在每次修改之后和第一次修改之前回答小YY的问题，这些操作是叠加的. 注意：小Y的字典也是叠加的，所以他会在每次修改之后和第一次修改之前将当前每一行每一列的单词加入字典 输入格式 第一行三个整数n,m,Qn,m,Q，表示方格纸的大小和修改次数。 接下来nn行每行mm个字符，表示方格纸上初始的字母。 接下来QQ行每行两个整数和一个字符x,y,chx,y,ch，表示一次修改。 输出格式 输出Q+1Q+1行，表示在第一次修改前和每次修改之后的答案。 样例输入 1 2 2 2 ab ba 1 2 a 2 1 a 样例输出 1 2 3 3 样例输入 2 2 2 2 ab ba 1 2 a 2 1 c 样例输出 2 2 3 5 样例输入 3 3 3 20 ccb bcb aab 3 3 c 2 1 b 3 2 c 1 1 a 1 3 a 2 2 a 3 3 c 3 1 c 1 1 b 3 2 b 1 3 a 3 1 a 3 1 b 3 2 c 3 2 a 1 2 c 1 2 b 2 3 c 1 1 b 2 3 b 样例输出 3 6 8 8 10 12 14 16 16 16 17 19 19 20 20 21 23 23 24 24 24 24 数据范围与提示 测试点编号 n,mn,m QQ 特殊性质 11 ≤10≤10 ≤200≤200 无 22 ≤30≤30 ≤300≤300 无 33 ≤100≤100 =0=0 无 44 ≤200≤200 ≤2000≤2000 无 55 ≤2000≤2000 =0=0 无 66 ≤2000≤2000 ≤2000≤2000 无 77 ≤2000≤2000 ≤105≤105 字符只有'a','b' 88 ≤2000≤2000 ≤105≤105 无 99 ≤3000≤3000 ≤5×105≤5×105 字符只有'a','b' 1010 ≤3000≤3000 ≤5×105≤5×105 无 std: #include&lt;bits/stdc++.h&gt; #define LL long long #define mp make_pair #define pb push_back using namespace std; const int Maxn=3005; const int mod1=998244353; const int mod2=1e9+7; const int bas=114514; int pw1[Maxn],pw2[Maxn]; int r1[Maxn],r2[Maxn]; int c1[Maxn],c2[Maxn]; int n,m,q; char s[Maxn][Maxn]; int hd[1145141],nxt[1145141],kc,sz; LL val[1145141]; void Ins(LL v){ int pos=v%1145141; bool flag=true; for (int i=hd[pos];~i;i=nxt[i]){ if (val[i]==v) flag=false; } if (flag){ val[kc]=v; nxt[kc]=hd[pos]; hd[pos]=kc++; sz++; } } int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); assert(1&lt;=n &amp;&amp; n&lt;=3000 &amp;&amp; 1&lt;=m &amp;&amp; m&lt;=3000 &amp;&amp; 0&lt;=q &amp;&amp; q&lt;=500000); for (int i=0;i&lt;n;i++){ scanf(&quot;%s&quot;,s[i]); for (int j=0;j&lt;m;j++){ assert(s[i][j]&gt;='a' &amp;&amp; s[i][j]&lt;='z'); } } pw1[0]=pw2[0]=1; for (int i=1;i&lt;n;i++){ pw1[i]=1ll*pw1[i-1]*bas%mod1; pw2[i]=1ll*pw2[i-1]*bas%mod2; } for (int i=0;i&lt;n;i++){ for (int j=0;j&lt;m;j++){ r1[i]=(1ll*r1[i]*bas+s[i][j])%mod1; r2[i]=(1ll*r2[i]*bas+s[i][j])%mod2; c1[j]=(1ll*c1[j]*bas+s[i][j])%mod1; c2[j]=(1ll*c2[j]*bas+s[i][j])%mod2; } } for (int i=0;i&lt;1145141;i++) hd[i]=-1; for (int i=0;i&lt;n;i++){ Ins(1ll*r1[i]*mod2+r2[i]); } for (int i=0;i&lt;m;i++){ Ins(1ll*c1[i]*mod2+c2[i]); } printf(&quot;%d\\n&quot;,sz); while (q--){ int x,y; char ch; scanf(&quot;%d %d %c&quot;,&amp;x,&amp;y,&amp;ch); assert(x&gt;=1 &amp;&amp; x&lt;=n &amp;&amp; y&gt;=1 &amp;&amp; y&lt;=m &amp;&amp; ch&gt;='a' &amp;&amp; ch&lt;='z'); x--;y--; int dlt=(int)ch-(int)s[x][y]; (r1[x]+=1ll*dlt*pw1[m-y-1]%mod1)%=mod1; if (r1[x]&lt;0) r1[x]+=mod1; (r2[x]+=1ll*dlt*pw2[m-y-1]%mod2)%=mod2; if (r2[x]&lt;0) r2[x]+=mod2; (c1[y]+=1ll*dlt*pw1[n-x-1]%mod1)%=mod1; if (c1[y]&lt;0) c1[y]+=mod1; (c2[y]+=1ll*dlt*pw2[n-x-1]%mod2)%=mod2; if (c2[y]&lt;0) c2[y]+=mod2; Ins(1ll*r1[x]*mod2+r2[x]); Ins(1ll*c1[y]*mod2+c2[y]); s[x][y]=ch; printf(&quot;%d\\n&quot;,sz); } return 0; } ","link":"https://aurora-wangq.github.io/post/csp-s2-zhou-mo-shua-ti-ban-di-yi-chang/"},{"title":"[模板]大根堆","content":"#include &lt;iostream&gt; //堆长度 int heapsize; //大顶堆化 void MAX_HEAPIFY(int A[], int i) { int l = 2 * i; //把 i 的左儿子 下标 赋给l int r = 2 * i + 1; //把 i 的左儿子 下标 赋给r int largest; //3个里面最大的下标 if (l &lt;= heapsize &amp;&amp; A[l]&gt;A[i]) largest = l; else largest = i; if (r &lt;= heapsize &amp;&amp; A[r]&gt;A[largest]) largest = r; if (largest != i) { //交换 A[largest] 和 A[i] int tmp = A[largest]; A[largest] = A[i]; A[i] = tmp; MAX_HEAPIFY(A, largest); } } //建堆 void BUILD_MAX_HEAP(int A[]) { int i; for (i = (int)(heapsize / 2); i &gt;= 1; i--) { MAX_HEAPIFY(A, i); for (int j = 1; j &lt;= 10; j++) printf(&quot;%d &quot;, A[j]); printf(&quot;\\n&quot;); } } //堆排序 void HEAPSORT(int A[]) { BUILD_MAX_HEAP(A); //ok int i; int tmp; for (i = heapsize; i &gt;= 2; i--) //A[1] 必定是最大的 { //交换 A[1] 和 A[i] tmp = A[1]; A[1] = A[i]; A[i] = tmp; heapsize--; MAX_HEAPIFY(A, 1); } } int main() { int A[11] = { 0, 5, 3, 2, 1, 4, 6, 9, 7, 8, 10 }; //ok int n = sizeof(A) / sizeof(int) - 1; heapsize = n; HEAPSORT(A); for (int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, A[i]); return 0; } ","link":"https://aurora-wangq.github.io/post/mo-ban-da-gen-dui/"}]}