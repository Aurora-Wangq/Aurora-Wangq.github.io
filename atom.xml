<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://aurora-wangq.github.io/</id>
    <title>Aurora</title>
    <updated>2020-10-20T12:45:35.453Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://aurora-wangq.github.io/"/>
    <link rel="self" href="https://aurora-wangq.github.io/atom.xml"/>
    <subtitle>WQJ_MKTB</subtitle>
    <logo>https://aurora-wangq.github.io/images/avatar.png</logo>
    <icon>https://aurora-wangq.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Aurora</rights>
    <entry>
        <title type="html"><![CDATA[加工工件]]></title>
        <id>https://aurora-wangq.github.io/post/jia-gong-gong-jian/</id>
        <link href="https://aurora-wangq.github.io/post/jia-gong-gong-jian/">
        </link>
        <updated>2020-10-20T12:41:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="加工工件"><a href="https://pan.baidu.com/s/1kKEKu7ByQa2QEq01Sggs-A">加工工件</a></h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Stack]]></title>
        <id>https://aurora-wangq.github.io/post/ti/</id>
        <link href="https://aurora-wangq.github.io/post/ti/">
        </link>
        <updated>2020-10-20T12:37:44.000Z</updated>
        <content type="html"><![CDATA[<p>#<a href="https://pan.baidu.com/s/13LE8U4KthCcmfeQxlI0uJQ">Stack</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020-10-19]]></title>
        <id>https://aurora-wangq.github.io/post/2020-10-19/</id>
        <link href="https://aurora-wangq.github.io/post/2020-10-19/">
        </link>
        <updated>2020-10-19T12:16:44.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h3 id="t1"><a href="https://www.luogu.com.cn/problem/P1280">T1</a></h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;  
#include&lt;algorithm&gt;  
using namespace std;

long int n,k,sum[10001],num=1,f[10001];  
long int i,j;

struct nk   
{  
    long int ks,js;  
};

nk z[10001];

int cmp(nk a,nk b) {

    return a.ks&gt;b.ks;  
}

int main()  
{  

    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);

    for(i=1;i&lt;=k;i++) {

        cin&gt;&gt;z[i].ks&gt;&gt;z[i].js;    
        sum[z[i].ks]++;  
    }  

    sort(z+1,z+k+1,cmp);  

    for(i=n;i&gt;=1;i--)  
    {  
        if(sum[i]==0)  
        f[i]=f[i+1]+1;  
        else for(j=1;j&lt;=sum[i];j++)  
        {  
            if(f[i+z[num].js]&gt;f[i])  
            f[i]=f[i+z[num].js];  
            num++;
        }  
    }  
    cout&lt;&lt;f[1]&lt;&lt;endl;  
}
</code></pre>
<h3 id="t2"><a href="https://www.luogu.com.cn/problem/P1095">T2</a></h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;

int m,s,t,dp[300001];

int main() {

    scanf(&quot;%d%d%d&quot;,&amp;m,&amp;s,&amp;t);

    for(int i=1;i&lt;=t;i++) {

        if(m&gt;=10) {

            dp[i]=dp[i-1]+60;
            m-=10;
        }
        else {

            m+=4;
            dp[i]=dp[i-1];    
        }
    }

    for(int i=1;i&lt;=t;i++) {

        dp[i]=max(dp[i],dp[i-1]+17);

        if(dp[i]&gt;=s) {

            printf(&quot;Yes\n%d&quot;,i);
            return 0;    
        }     
    } 

        printf(&quot;No\n%d&quot;,dp[t]);

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4305 [JLOI2011]不重复数字]]></title>
        <id>https://aurora-wangq.github.io/post/p4305-jloi2011bu-chong-fu-shu-zi/</id>
        <link href="https://aurora-wangq.github.io/post/p4305-jloi2011bu-chong-fu-shu-zi/">
        </link>
        <updated>2020-10-18T03:42:22.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p><strong>哈希</strong><br>
思路 <strong><s>很简单</s></strong></p>
<ol>
<li>以二维vector为容器，第一维下标存储哈希值，第二维下标存储此哈希值下原数字的个数，数组值存储原数字。</li>
<li>输入一个数，找其对应哈希值下的数组内有没有和它相同的数字，相当于缩小了枚举的范围，因为原值相同的数哈希值一定相同，而不同的数哈希值也是可能相同的，所以要同时存储哈希值和原值。</li>
<li>如果没有重复的输出，有重复的不输出。</li>
<li>注意，由于是多组询问，每次都要把vector清零。</li>
</ol>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#define ll long long
using namespace std;

const int mod=100007;
const int maxn=5*1e5+7;
vector&lt;int&gt; h[mod];
int maxk,n,t;
ll tong[mod]; 

int hashe(int a) {return a=(a%mod+mod)%mod;}//哈希 

int find(int val) {
	
	int hx=hashe(val);
	maxk=max(maxk,hx);
	
	for(int i=0;i&lt;h[hx].size();i++) {
		
		if(h[hx][i]==val) return 0;
	}
	
	h[hx].push_back(val);
		
	return 1;
}//判重

int main() {
	
	scanf(&quot;%d&quot;,&amp;t);
	
	int num,n;
	
	for(int i=1;i&lt;=t;i++) {
		
		scanf(&quot;%d&quot;,&amp;n);
		
		for(int p=0;p&lt;=maxk;p++) h[p].clear();//注意多次操作,要重新清零 
		maxk=0;
		
		for(int j=1;j&lt;=n;j++) {
			
			scanf(&quot;%d&quot;,&amp;num);
			
			if(find(num)==1) printf(&quot;%d &quot;,num);  
		}
		
		printf(&quot;\n&quot;);
	}
	return 0;
} 
</code></pre>
<hr>
<p>用vector的时候突发奇想试验了一下vector的原理结果发现<br>
<img src="https://i.loli.net/2020/10/18/AauX1o6xbC2ZUsH.png" alt="c++" loading="lazy"><br>
而更加鬼畜的是同样的代码在vscode中编译会报错，十分玄学。看来是<strong>Dev-Cpp</strong>的锅。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-S2周末刷题班（第一场）]]></title>
        <id>https://aurora-wangq.github.io/post/csp-s2-zhou-mo-shua-ti-ban-di-yi-chang/</id>
        <link href="https://aurora-wangq.github.io/post/csp-s2-zhou-mo-shua-ti-ban-di-yi-chang/">
        </link>
        <updated>2020-10-17T09:18:27.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p><strong>题面好像有一点锅</strong></p>
<h2 id="a">A</h2>
<p>小YY有一个nn行mm列的方格纸，每一个格子上都写有一个小写英文字母。</p>
<p>小YY会将每一行单独取出来，将这一行的字符从左到右拼起来组成一个单词，并将这个单词加入小YY的字典。</p>
<p>类似的，小YY也会将每一列单独取出来，将这一列的字符从上到下拼起来组成一个单词，并将这个单词加入字典。</p>
<p>现在，小YY想知道，他的字典里有多少本质不同的单词？两个单词本质相同当且仅当他们长度相同且对应位置都相同。</p>
<p>方格纸上的字母可能会有修改，具体来说，有QQ次修改，每次将第xx行第yy列的字符修改为chch, 你需要在每次修改之后和第一次修改之前回答小YY的问题，<strong>这些操作是叠加的</strong>.</p>
<p><strong>注意：小Y的字典也是叠加的，所以他会在每次修改之后和第一次修改之前将当前每一行每一列的单词加入字典</strong></p>
<h4 id="输入格式">输入格式</h4>
<p>第一行三个整数n,m,Qn,m,Q，表示方格纸的大小和修改次数。</p>
<p>接下来nn行每行mm个字符，表示方格纸上初始的字母。</p>
<p>接下来QQ行每行两个整数和一个字符x,y,chx,y,ch，表示一次修改。</p>
<h4 id="输出格式">输出格式</h4>
<p>输出Q+1Q+1行，表示在第一次修改前和每次修改之后的答案。</p>
<h4 id="样例输入-1">样例输入 1</h4>
<pre><code>2 2 2
ab
ba
1 2 a
2 1 a
</code></pre>
<h4 id="样例输出-1">样例输出 1</h4>
<pre><code>2
3
3
</code></pre>
<h4 id="样例输入-2">样例输入 2</h4>
<pre><code>2 2 2
ab
ba
1 2 a
2 1 c
</code></pre>
<h4 id="样例输出-2">样例输出 2</h4>
<pre><code>2
3
5
</code></pre>
<h4 id="样例输入-3">样例输入 3</h4>
<pre><code>3 3 20
ccb
bcb
aab
3 3 c
2 1 b
3 2 c
1 1 a
1 3 a
2 2 a
3 3 c
3 1 c
1 1 b
3 2 b
1 3 a
3 1 a
3 1 b
3 2 c
3 2 a
1 2 c
1 2 b
2 3 c
1 1 b
2 3 b
</code></pre>
<h4 id="样例输出-3">样例输出 3</h4>
<pre><code>6
8
8
10
12
14
16
16
16
17
19
19
20
20
21
23
23
24
24
24
24
</code></pre>
<h4 id="数据范围与提示">数据范围与提示</h4>
<table>
<thead>
<tr>
<th>测试点编号</th>
<th>n,mn,m</th>
<th>QQ</th>
<th>特殊性质</th>
</tr>
</thead>
<tbody>
<tr>
<td>11</td>
<td>≤10≤10</td>
<td>≤200≤200</td>
<td>无</td>
</tr>
<tr>
<td>22</td>
<td>≤30≤30</td>
<td>≤300≤300</td>
<td>无</td>
</tr>
<tr>
<td>33</td>
<td>≤100≤100</td>
<td>=0=0</td>
<td>无</td>
</tr>
<tr>
<td>44</td>
<td>≤200≤200</td>
<td>≤2000≤2000</td>
<td>无</td>
</tr>
<tr>
<td>55</td>
<td>≤2000≤2000</td>
<td>=0=0</td>
<td>无</td>
</tr>
<tr>
<td>66</td>
<td>≤2000≤2000</td>
<td>≤2000≤2000</td>
<td>无</td>
</tr>
<tr>
<td>77</td>
<td>≤2000≤2000</td>
<td>≤105≤105</td>
<td>字符只有'a','b'</td>
</tr>
<tr>
<td>88</td>
<td>≤2000≤2000</td>
<td>≤105≤105</td>
<td>无</td>
</tr>
<tr>
<td>99</td>
<td>≤3000≤3000</td>
<td>≤5×105≤5×105</td>
<td>字符只有'a','b'</td>
</tr>
<tr>
<td>1010</td>
<td>≤3000≤3000</td>
<td>≤5×105≤5×105</td>
<td>无</td>
</tr>
</tbody>
</table>
<!-- more -->
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define LL long long
#define mp make_pair
#define pb push_back
using namespace std;
const int Maxn=3005;
const int mod1=998244353;
const int mod2=1e9+7;
const int bas=114514;
int pw1[Maxn],pw2[Maxn];
int r1[Maxn],r2[Maxn];
int c1[Maxn],c2[Maxn];
int n,m,q;
char s[Maxn][Maxn];
int hd[1145141],nxt[1145141],kc,sz;
LL val[1145141];
void Ins(LL v){
	int pos=v%1145141;
	bool flag=true;
	for (int i=hd[pos];~i;i=nxt[i]){
		if (val[i]==v) flag=false;
	}
	if (flag){
		val[kc]=v;
		nxt[kc]=hd[pos];
		hd[pos]=kc++;
		sz++;
	}
}

int main() {
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q);
	assert(1&lt;=n &amp;&amp; n&lt;=3000 &amp;&amp; 1&lt;=m &amp;&amp; m&lt;=3000 &amp;&amp; 0&lt;=q &amp;&amp; q&lt;=500000);
	for (int i=0;i&lt;n;i++){
		scanf(&quot;%s&quot;,s[i]);
		for (int j=0;j&lt;m;j++){
			assert(s[i][j]&gt;='a' &amp;&amp; s[i][j]&lt;='z');
		}
	}
	pw1[0]=pw2[0]=1;
	for (int i=1;i&lt;n;i++){
		pw1[i]=1ll*pw1[i-1]*bas%mod1;
		pw2[i]=1ll*pw2[i-1]*bas%mod2;
	}
	for (int i=0;i&lt;n;i++){
		for (int j=0;j&lt;m;j++){
			r1[i]=(1ll*r1[i]*bas+s[i][j])%mod1;
			r2[i]=(1ll*r2[i]*bas+s[i][j])%mod2;
			
			c1[j]=(1ll*c1[j]*bas+s[i][j])%mod1;
			c2[j]=(1ll*c2[j]*bas+s[i][j])%mod2;
		}
	}
	for (int i=0;i&lt;1145141;i++) hd[i]=-1;
	for (int i=0;i&lt;n;i++){
		Ins(1ll*r1[i]*mod2+r2[i]);
	}
	for (int i=0;i&lt;m;i++){
		Ins(1ll*c1[i]*mod2+c2[i]);
	}
	
	printf(&quot;%d\n&quot;,sz);
	while (q--){
		int x,y;
		char ch;
		scanf(&quot;%d %d %c&quot;,&amp;x,&amp;y,&amp;ch);
		assert(x&gt;=1 &amp;&amp; x&lt;=n &amp;&amp; y&gt;=1 &amp;&amp; y&lt;=m &amp;&amp; ch&gt;='a' &amp;&amp; ch&lt;='z');
		x--;y--;
		int dlt=(int)ch-(int)s[x][y];
		(r1[x]+=1ll*dlt*pw1[m-y-1]%mod1)%=mod1;
		if (r1[x]&lt;0) r1[x]+=mod1;
		(r2[x]+=1ll*dlt*pw2[m-y-1]%mod2)%=mod2;
		if (r2[x]&lt;0) r2[x]+=mod2;
		(c1[y]+=1ll*dlt*pw1[n-x-1]%mod1)%=mod1;
		if (c1[y]&lt;0) c1[y]+=mod1;
		(c2[y]+=1ll*dlt*pw2[n-x-1]%mod2)%=mod2;
		if (c2[y]&lt;0) c2[y]+=mod2;
		Ins(1ll*r1[x]*mod2+r2[x]);
		Ins(1ll*c1[y]*mod2+c2[y]);
		s[x][y]=ch;
		printf(&quot;%d\n&quot;,sz);
	}
	return 0;
	
}
</code></pre>
<hr>
<h2 id="b">B</h2>
<p>小YY有一棵nn个点n−1n−1条边的树，他首先会选择其中一个点作为起点，然后开始他的树上之旅。</p>
<p>他每次可以选择以下三种操作之一。</p>
<ol>
<li>结束这次旅行，小YY当前所在的节点就是终点。</li>
<li>走正好aa步，每一步走到当前点相邻的一个点，不能经过所有之前走到过的边。</li>
<li>走正好bb步，每一步走到当前点相邻的一个点，不能经过所有之前走到过的边。</li>
</ol>
<p>现在他想知道，对于每个的起点v=1...nv=1...n, 能走到多少个不同的终点？</p>
<p>多组测试。</p>
<h4 id="输入格式-2">输入格式</h4>
<p>第一行一个整数TT，表示测试点个数。</p>
<p>每个测试点第一行三个整数n,a,bn,a,b.</p>
<p>接下来n−1n−1行每行两个整数u,vu,v表示树上的一条边。</p>
<h4 id="输出格式-2">输出格式</h4>
<p>输出一行nn个数，第ii个数表示ii号点作为起点的答案。</p>
<h4 id="输入样例-1">输入样例 1</h4>
<pre><code>1
5 2 3
1 2
1 3
3 4
4 5
</code></pre>
<h4 id="输出样例-1">输出样例 1</h4>
<pre><code>3 4 3 3 4
</code></pre>
<h4 id="输入样例-2">输入样例 2</h4>
<pre><code>2
10 3 4
1 2
1 3
3 4
3 5
4 6
4 7
4 8
8 9
9 10
10 2 2
1 2
1 3
3 4
3 5
4 6
4 7
4 8
8 9
9 10
</code></pre>
<h4 id="输出样例-2">输出样例 2</h4>
<pre><code>5 7 3 3 6 6 6 4 6 6 
4 6 6 4 4 6 6 6 4 6
</code></pre>
<h4 id="数据范围与提示-2">数据范围与提示</h4>
<table>
<thead>
<tr>
<th>测试点编号</th>
<th>nn</th>
<th>a,ba,b</th>
<th>特殊性质</th>
</tr>
</thead>
<tbody>
<tr>
<td>11</td>
<td>≤100≤100</td>
<td>≤10≤10</td>
<td>无</td>
</tr>
<tr>
<td>22</td>
<td>≤2000≤2000</td>
<td>≤10≤10</td>
<td>无</td>
</tr>
<tr>
<td>33</td>
<td>≤105≤105</td>
<td>≤5≤5</td>
<td>a=ba=b</td>
</tr>
<tr>
<td>44</td>
<td>≤105≤105</td>
<td>≤5≤5</td>
<td>a,b互质a,b互质</td>
</tr>
<tr>
<td>55</td>
<td>≤105≤105</td>
<td>≤10≤10</td>
<td>a=ba=b</td>
</tr>
<tr>
<td>66</td>
<td>≤105≤105</td>
<td>≤10≤10</td>
<td>树随机生成</td>
</tr>
<tr>
<td>77</td>
<td>≤105≤105</td>
<td>≤10≤10</td>
<td>树形态为一条链</td>
</tr>
<tr>
<td>88</td>
<td>≤105≤105</td>
<td>≤5≤5</td>
<td>无</td>
</tr>
<tr>
<td>99</td>
<td>≤105≤105</td>
<td>≤10≤10</td>
<td>无</td>
</tr>
<tr>
<td>1010</td>
<td>≤105≤105</td>
<td>≤10≤10</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>对于所有的数据，T≤3,n≤105,1≤a,b≤10,1≤u,v≤n,u≠v</p>
<!-- more -->
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define LL long long
#define pb push_back
#define mp make_pair
#define pii pair&lt;int,int&gt;
using namespace std;
namespace IO
{
    const int sz=1&lt;&lt;15;
    char inbuf[sz],outbuf[sz];
    char *pinbuf=inbuf+sz;
    char *poutbuf=outbuf;
    inline char _getchar()
    {
        if (pinbuf==inbuf+sz)fread(inbuf,1,sz,stdin),pinbuf=inbuf;
        return *(pinbuf++);
    }
    inline void _putchar(char x)
    {
        if (poutbuf==outbuf+sz)fwrite(outbuf,1,sz,stdout),poutbuf=outbuf;
        *(poutbuf++)=x;
    }
    inline void flush()
    {
        if (poutbuf!=outbuf)fwrite(outbuf,1,poutbuf-outbuf,stdout),poutbuf=outbuf;
    }
}
inline int read(){
	int v=0,f=1;
	char c=getchar();
	while (c&lt;'0' || c&gt;'9'){
		if (c=='-') f=-1;
		c=getchar();
	}
	while (c&gt;='0' &amp;&amp; c&lt;='9'){
		v=v*10+c-'0';
		c=getchar();
	}
	return v*f;
}
const int Maxn=100005;
int n,a,b,g,D;
vector&lt;int&gt; G[Maxn];
int dp1[Maxn][80],dp2[Maxn][11];
int ans1[Maxn][80],ans2[Maxn][80];
void dfs1(int x,int p){
	dp1[x][0]=1;dp2[x][0]=1;
	for (int i=0;i&lt;G[x].size();i++){
		int v=G[x][i];
		if (v!=p){
			dfs1(v,x);
			for (int j=1;j&lt;=D;j++){
				dp1[x][j]+=dp1[v][j-1];
			}
			for (int j=0;j&lt;g;j++){
				dp2[x][(j+1)%g]+=dp2[v][j];
			}
		}
	}
}
void dfs2(int x,int p,vector&lt;int&gt; U1,vector&lt;int&gt; U2){
	for (int i=0;i&lt;=D;i++){
		ans1[x][i]=dp1[x][i]+U1[i];
		
		U1[i]+=dp1[x][i];
		
	}
	for (int i=0;i&lt;g;i++){
		ans2[x][i]=dp2[x][i]+U2[i];
		U2[i]+=dp2[x][i];
	}
	for (int i=0;i&lt;G[x].size();i++){
		int v=G[x][i];
		if (v==p) continue;
		for (int j=0;j&lt;=D-1;j++){
			U1[j+1]-=dp1[v][j];
		}
		for (int j=0;j&lt;g;j++){
			U2[(j+1)%g]-=dp2[v][j];
		}
		vector&lt;int&gt; N1,N2;
		N1.resize(D+1,0);N2.resize(g,0);
		for (int j=1;j&lt;=D;j++) N1[j]=U1[j-1];
		for (int j=0;j&lt;g;j++){
			N2[(j+1)%g]=U2[j];
		}
		dfs2(v,x,N1,N2);
		for (int j=0;j&lt;=D-1;j++){
			U1[j+1]+=dp1[v][j];
		}
		for (int j=0;j&lt;g;j++){
			U2[(j+1)%g]+=dp2[v][j];
		}
	}
}
bool AV[114];
void mian(){
	for (int i=0;i&lt;Maxn;i++) G[i].clear();
	n=read();a=read();b=read();
//	cerr&lt;&lt;n&lt;&lt;' '&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;
	g=__gcd(a,b);
	D=max(0,((a/g)*(b/g)-(a/g)-(b/g)))*g;
//	cerr&lt;&lt;D&lt;&lt;' '&lt;&lt;g&lt;&lt;endl;
	for (int i=0;i&lt;n-1;i++){
		int u,v;
		u=read();v=read();
		G[u].pb(v);G[v].pb(u);
	}
	memset(dp1,0,sizeof(dp1));memset(dp2,0,sizeof(dp2));
	dfs1(1,-1);
	
	vector&lt;int&gt; V1,V2;
	V1.resize(D+1,0);V2.resize(g,0);
	dfs2(1,-1,V1,V2);
	
	int A=a/g,B=b/g;
	memset(AV,0,sizeof(AV));
	AV[0]=1;
	for (int i=1;i&lt;=D;i++){
		if (i&gt;=a) AV[i]|=AV[i-a];
		if (i&gt;=b) AV[i]|=AV[i-b];
	}
	
	for (int i=1;i&lt;=n;i++){
		int res=ans2[i][0];
		//cerr&lt;&lt;i&lt;&lt;' '&lt;&lt;res&lt;&lt;' ';
		for (int j=0;j&lt;=D;j+=g){
			if (!AV[j]){
			//	cerr&lt;&lt;&quot;DEL&quot;&lt;&lt;j&lt;&lt;endl;
				res-=ans1[i][j];
			}
		}
		printf(&quot;%d &quot;,res);
	}
	printf(&quot;\n&quot;);
}
int main(){
//	freopen(&quot;ex_a2.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;ex_a2.out&quot;,&quot;w&quot;,stdout);
	int T=read();
	while (T--){
		mian();
	}
	return 0;
}
</code></pre>
<hr>
<h2 id="c">C</h2>
<p>小YY非常喜欢打电动，某天他在电玩厅里发现了一台新的机器。</p>
<p>这个机器和普通的没什么区别，只需要投入一枚游戏币即可开始一次游戏，机器内部有一个金字塔，高度为hh，从上到下数第ii层有ii个格子。</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/10/13/RgrvTAIWYmCM6ne.png" alt="image.png" loading="lazy"></figure>
<p>上图即为一个h=4h=4的金字塔。</p>
<p>一次游戏分为若干轮，在第xx轮里（初始为第00轮）小YY可以选择结束游戏，获得ax2+bxax2+bx个彩票的奖励，也可以选择继续掷球。选择掷球后会有一个小球出现在第一层的格子内，它会等概率落在下一层左边或者右边的格子中直到落到最后一层（即第hh层），如果它的最终落点已经存在了其他的小球，那么游戏结束，小YY无法获得任何彩票。如果它的最终落点是空的那么小YY就可以开始下一轮的选择。</p>
<p>给定这台机器的参数a,b,ha,b,h，小YY想知道，如果采取最优的策略，一枚游戏币期望能获得多少彩票？</p>
<h4 id="输入格式-3">输入格式</h4>
<p>第一行一个整数TT，表示测试点个数。</p>
<p>接下来TT个测试点。</p>
<p>每个测试点一行三个正整数h,a,bh,a,b，表示机器的参数。</p>
<h4 id="输出格式-3">输出格式</h4>
<p>对于每个测试点，输出一行一个实数四舍五入到第四位小数，表示答案。</p>
<h4 id="样例输入-1-2">样例输入 1</h4>
<pre><code>3
2 1 1
2 0 1
6 12 14
</code></pre>
<h4 id="样例输出-1-2">样例输出 1</h4>
<pre><code>3.0000
1.0000
63.9481
</code></pre>
<h4 id="数据范围与提示-3">数据范围与提示</h4>
<table>
<thead>
<tr>
<th>测试点编号</th>
<th>hh</th>
</tr>
</thead>
<tbody>
<tr>
<td>11</td>
<td>=2=2</td>
</tr>
<tr>
<td>22</td>
<td>=3=3</td>
</tr>
<tr>
<td>33</td>
<td>=5=5</td>
</tr>
<tr>
<td>44</td>
<td>=8=8</td>
</tr>
<tr>
<td>55</td>
<td>=10=10</td>
</tr>
<tr>
<td>66</td>
<td>=15=15</td>
</tr>
<tr>
<td>77</td>
<td>=21=21</td>
</tr>
<tr>
<td>88</td>
<td>=22=22</td>
</tr>
<tr>
<td>99</td>
<td>=24=24</td>
</tr>
<tr>
<td>1010</td>
<td>=26=26</td>
</tr>
</tbody>
</table>
<p>对于所有的测试点,T≤3,1≤h≤26,0≤a,b≤106T≤3,1≤h≤26,0≤a,b≤106</p>
<!-- more -->
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define LL long long
#define pb push_back
#define mp make_pair
#define pii pair&lt;int,int&gt;
using namespace std;
namespace IO
{
    const int sz=1&lt;&lt;15;
    char inbuf[sz],outbuf[sz];
    char *pinbuf=inbuf+sz;
    char *poutbuf=outbuf;
    inline char _getchar()
    {
        if (pinbuf==inbuf+sz)fread(inbuf,1,sz,stdin),pinbuf=inbuf;
        return *(pinbuf++);
    }
    inline void _putchar(char x)
    {
        if (poutbuf==outbuf+sz)fwrite(outbuf,1,sz,stdout),poutbuf=outbuf;
        *(poutbuf++)=x;
    }
    inline void flush()
    {
        if (poutbuf!=outbuf)fwrite(outbuf,1,poutbuf-outbuf,stdout),poutbuf=outbuf;
    }
}
inline int read(){
	int v=0,f=1;
	char c=getchar();
	while (c&lt;'0' || c&gt;'9'){
		if (c=='-') f=-1;
		c=getchar();
	}
	while (c&gt;='0' &amp;&amp; c&lt;='9'){
		v=v*10+c-'0';
		c=getchar();
	}
	return v*f;
}
const int Maxn=30;
int C[Maxn][Maxn];
void _init(){
	C[0][0]=1;
	for(int i=1;i&lt;Maxn;i++){
		C[i][0]=1;
		for (int j=1;j&lt;=i;j++){
			C[i][j]=C[i-1][j]+C[i-1][j-1];
		}
	}
}
int n,a,b;
double p[Maxn];
double dp[67108864];
double Go(int mask){
	if (dp[mask]&gt;=0){
		return dp[mask];
	}
	
	int x=__builtin_popcount(mask);
	double vv=1.0*a*x*x+1.0*b*x;
	
	double v=0.0;
	for (int i=0;i&lt;n;i++){
		if (mask&gt;&gt;i&amp;1) continue;
		int nmask=mask;
		if (n-i-1&lt;i &amp;&amp; !(mask&gt;&gt;(n-i-1)&amp;1)){
			nmask^=1&lt;&lt;(n-i-1);
		}
		else{
			nmask^=1&lt;&lt;i;
		}
		v+=p[i]*Go(nmask);
	}
	return dp[mask]=max(v,vv);
}
void mian(){
	
	n=read();a=read();b=read();
	int tot=1&lt;&lt;(n-1);
	for (int i=0;i&lt;n;i++){
		p[i]=(double)C[n-1][i]/tot;
	}
	for (int i=0;i&lt;(1&lt;&lt;n);i++){
		dp[i]=-1.0;
	}
	printf(&quot;%.4lf\n&quot;,Go(0));
}
int main(){
	_init();
	int T=read();
	while (T--){
		mian();
	}
}
</code></pre>
<hr>
<h2 id="d">D</h2>
<p>小YY被困在了一个NN行MM列的网格图上。</p>
<p>从上往下第ii行从左往右第jj列(1≤i≤N,1≤j≤M)(1≤i≤N,1≤j≤M)的格子坐标为(i,j)(i,j). 他的初始位置在(1,1)(1,1)格子的左侧，第一步一定走到(1,1)(1,1). 网格图有一个终点位于(N,M)(N,M)格子的右侧，只能从(N,M)(N,M)格子向右走到。</p>
<p>小YY的初始方向向右，每一步小YY会沿着当前方向前进一格然后旋转90度（他可以选择顺时针或者逆时针），小YY不愿意走回头路，所以他不希望旋转过后他的方向向左。</p>
<p>你需要帮助他设计一条路线，这条路线不能经过相同的格子且最终要到达终点。</p>
<p>小YY的朋友小ZZ觉得这个问题太过简单，小ZZ想知道有多少种不同的设计方案。</p>
<p>小ZZ的朋友小AA觉得这个问题还是太简单，初始图上没有障碍物，小AA给出了QQ次修改，每次修改在网格图上的某一个点上添加障碍物，你设计的路线不能经过含有障碍物的点，每次修改后你需要回答有多少种不同的设计方案，由于这个数可能很大，所以你只需要输出答案对998244353998244353取模的结果。</p>
<h4 id="输入格式-4">输入格式</h4>
<p>第一行三个正整数N,M,QN,M,Q</p>
<p>接下来QQ行每行两个正整数x,yx,y表示修改的格子。</p>
<p><strong>可能存在被修改多次的格子</strong></p>
<h4 id="输出格式-4">输出格式</h4>
<p>输出QQ行，每行一个整数，表示每次修改后的答案。</p>
<h4 id="样例输入-1-3">样例输入 1</h4>
<pre><code>3 6 2
1 5
3 3
</code></pre>
<h4 id="样例输出-1-3">样例输出 1</h4>
<pre><code>2
1
</code></pre>
<h4 id="样例输入-2-2">样例输入 2</h4>
<pre><code>4 7 2
1 6
3 3
</code></pre>
<h4 id="样例输出-2-2">样例输出 2</h4>
<pre><code>8
3
</code></pre>
<h4 id="数据范围与提示-4">数据范围与提示</h4>
<table>
<thead>
<tr>
<th>测试点编号</th>
<th>NN</th>
<th>MM</th>
<th>QQ</th>
</tr>
</thead>
<tbody>
<tr>
<td>11</td>
<td>=3=3</td>
<td>≤5≤5</td>
<td>=5=5</td>
</tr>
<tr>
<td>22</td>
<td>=2=2</td>
<td>≤105≤105</td>
<td>=105=105</td>
</tr>
<tr>
<td>33</td>
<td>=3=3</td>
<td>≤103≤103</td>
<td>=5=5</td>
</tr>
<tr>
<td>44</td>
<td>=3=3</td>
<td>≤103≤103</td>
<td>=103=103</td>
</tr>
<tr>
<td>55</td>
<td>=3=3</td>
<td>≤105≤105</td>
<td>=105=105</td>
</tr>
<tr>
<td>66</td>
<td>=3=3</td>
<td>≤105≤105</td>
<td>=105=105</td>
</tr>
<tr>
<td>77</td>
<td>=3=3</td>
<td>≤109≤109</td>
<td>=100=100</td>
</tr>
<tr>
<td>88</td>
<td>=3=3</td>
<td>≤109≤109</td>
<td>=105=105</td>
</tr>
<tr>
<td>99</td>
<td>=4=4</td>
<td>≤105≤105</td>
<td>=5×104=5×104</td>
</tr>
<tr>
<td>1010</td>
<td>=4=4</td>
<td>≤109≤109</td>
<td>=105=105</td>
</tr>
</tbody>
</table>
<p>对于所有的数据,2≤N≤4,3≤M≤109,1≤Q≤105,1≤x≤N,1≤y≤M2≤N≤4,3≤M≤109,1≤Q≤105,1≤x≤N,1≤y≤M</p>
<!-- more -->
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define LL long long
#define pb push_back
#define mp make_pair
#define pii pair&lt;int,int&gt;
using namespace std;
namespace IO
{
    const int sz=1&lt;&lt;15;
    char inbuf[sz],outbuf[sz];
    char *pinbuf=inbuf+sz;
    char *poutbuf=outbuf;
    inline char _getchar()
    {
        if (pinbuf==inbuf+sz)fread(inbuf,1,sz,stdin),pinbuf=inbuf;
        return *(pinbuf++);
    }
    inline void _putchar(char x)
    {
        if (poutbuf==outbuf+sz)fwrite(outbuf,1,sz,stdout),poutbuf=outbuf;
        *(poutbuf++)=x;
    }
    inline void flush()
    {
        if (poutbuf!=outbuf)fwrite(outbuf,1,poutbuf-outbuf,stdout),poutbuf=outbuf;
    }
}
inline int read(){
	int v=0,f=1;
	char c=getchar();
	while (c&lt;'0' || c&gt;'9'){
		if (c=='-') f=-1;
		c=getchar();
	}
	while (c&gt;='0' &amp;&amp; c&lt;='9'){
		v=v*10+c-'0';
		c=getchar();
	}
	return v*f;
}

const int Maxn=214514;
const int mod=998244353;
int n,m,q;
struct mat{
	int v[4][4];
	int x,y;
	mat(int _x=0,int _y=0){
		x=_x,y=_y;
		memset(v,0,sizeof(v));
	}
};
mat mul(mat A,mat B){
	mat C(A.x,B.y);
	for (int i=0;i&lt;A.x;i++){
		for (int j=0;j&lt;B.y;j++){
			LL tmp=0;
			for (int k=0;k&lt;A.y;k++){
				tmp+=1ll*A.v[i][k]*B.v[k][j];
			}
			C.v[i][j]=tmp%mod;
		}
	}
	return C;
}
mat Qp(mat A,int p){
	
	mat ret(A.x,A.x);
	for (int i=0;i&lt;A.x;i++) ret.v[i][i]=1;
	while (p){
		if (p&amp;1){
			ret=mul(ret,A);
		}
		p&gt;&gt;=1;
		A=mul(A,A);
	}
	return ret;
}

int x[Maxn],y[Maxn];
vector&lt;int&gt; X;
mat O[16];
mat S[Maxn],tree[Maxn*4]; 
int msk[Maxn];
void build(int p,int l,int r){
	if (l==r){
		tree[p]=S[l];
		return;
	}
	int mid=l+r&gt;&gt;1;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
	tree[p]=mul(tree[p*2],tree[p*2+1]);
}
void modify(int p,int l,int r,int pos,mat T){
	if (l==r){
		tree[p]=T;
		return;
	}
	int mid=l+r&gt;&gt;1;
	if (pos&lt;=mid){
		modify(p*2,l,mid,pos,T);
	}
	else{
		modify(p*2+1,mid+1,r,pos,T);
	}
	tree[p]=mul(tree[p*2],tree[p*2+1]);
}
int main(){
	n=read();m=read();q=read();
	assert(n&gt;=2 &amp;&amp; n&lt;=4);
	assert(m&gt;=1 &amp;&amp; m&lt;=1000000000);
	assert(q&gt;=1 &amp;&amp; q&lt;=100000);
	for (int i=0;i&lt;q;i++){
		x[i]=read();y[i]=read();x[i]--;
		assert(x[i]&gt;=0 &amp;&amp; x[i]&lt;n &amp;&amp; y[i]&gt;=1 &amp;&amp; y[i]&lt;=m);
		X.pb(y[i]);X.pb(y[i]+1);
	}
	X.pb(m+1);X.pb(1);sort(X.begin(),X.end());
	X.resize(unique(X.begin(),X.end())-X.begin());
	
	for (int i=0;i&lt;(1&lt;&lt;n);i++){
		O[i].x=O[i].y=n;
		for (int j=0;j&lt;n-1;j++){
			if (i&gt;&gt;j&amp;1) continue;
			if (i&gt;&gt;(j+1)&amp;1) continue;
			
			O[i].v[j][j+1]=O[i].v[j+1][j]=1;
		}
	}
	//cerr&lt;&lt;123&lt;&lt;endl;
	int N=X.size();
	//0-(N-2);
	for (int i=0;i&lt;N-1;i++){
		int len=X[i+1]-X[i];
		assert(len&gt;=0);
		S[i]=Qp(O[0],len);
	}
	build(1,0,N-2);
	for (int i=0;i&lt;q;i++){
		int pos=lower_bound(X.begin(),X.end(),y[i])-X.begin();
		msk[pos]|=1&lt;&lt;x[i];
		modify(1,0,N-2,pos,O[msk[pos]]);
		
		printf(&quot;%d\n&quot;,tree[1].v[0][n-1]);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020-10-17]]></title>
        <id>https://aurora-wangq.github.io/post/zi-fu-chuan-ha-xi/</id>
        <link href="https://aurora-wangq.github.io/post/zi-fu-chuan-ha-xi/">
        </link>
        <updated>2020-10-17T03:25:23.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h3 id="t1字符串哈希">T1<a href="https://www.luogu.com.cn/problem/P3370">字符串哈希</a></h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define ull unsigned long long
using namespace std;

ull base=131;
ull a[10001];
char s[10001];
int n,ans=1;
int prime=23333; 
ull mod=1e9+7;

ull hax(char s[])
{

 int len=strlen(s);
 ull ans=0;
 for (int i=0;i&lt;len;i++)
 ans=(ans*base+(ull)s[i])%mod+prime;
 return ans;
}

int main()
{

 scanf(&quot;%d&quot;,&amp;n);
 for(int i=1;i&lt;=n;i++) {

     scanf(&quot;%s&quot;,s);
     a[i]=hax(s);
}

 sort(a+1,a+n+1);

 for(int i=1;i&lt;n;i++) {

     if(a[i]!=a[i+1])
     ans++;
 }

 printf(&quot;%d&quot;,ans);
 return 0;
}
</code></pre>
<h3 id="t2blocks">T2<a href="http://csp.ac/problem/281">blocks</a></h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;

int n;
int a[100100];

int main()
{

    scanf(&quot;%d&quot;,&amp;n);

    int ans=-1;
    for (int i = 1;i &lt;= n;i++) {

        scanf(&quot;%d&quot;,&amp;a[i]);

        if (i != 1)
            ans=ans==-1?a[i-1]-a[i] : min(ans,a[i-1]-a[i]);    
    }
    printf(&quot;%d&quot;,ans);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[模板]大根堆]]></title>
        <id>https://aurora-wangq.github.io/post/mo-ban-da-gen-dui/</id>
        <link href="https://aurora-wangq.github.io/post/mo-ban-da-gen-dui/">
        </link>
        <updated>2020-10-15T10:48:20.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">#include &lt;iostream&gt;

//堆长度
int heapsize;
 
//大顶堆化
void MAX_HEAPIFY(int A[], int i)
{
	int l = 2 * i;		//把 i 的左儿子 下标 赋给l
	int r = 2 * i + 1;		//把 i 的左儿子 下标 赋给r
	int largest;	//3个里面最大的下标
 
	if (l &lt;= heapsize &amp;&amp; A[l]&gt;A[i])
		largest = l;
	else
		largest = i;
 
	if (r &lt;= heapsize &amp;&amp; A[r]&gt;A[largest])
		largest = r;
 
	if (largest != i)
	{
		//交换 A[largest] 和 A[i]
		int tmp = A[largest];
		A[largest] = A[i];
		A[i] = tmp;
 
		MAX_HEAPIFY(A, largest);
	}
}
 
//建堆
void BUILD_MAX_HEAP(int A[])
{
	int i;
	for (i = (int)(heapsize / 2); i &gt;= 1; i--) {
		MAX_HEAPIFY(A, i);
		for (int j = 1; j &lt;= 10; j++)
			printf(&quot;%d &quot;, A[j]);
		printf(&quot;\n&quot;);
	}
}
 
//堆排序
void HEAPSORT(int A[])
{
	BUILD_MAX_HEAP(A);		//ok
 
	int i;
	int tmp;
	for (i = heapsize; i &gt;= 2; i--)		//A[1] 必定是最大的
	{
		//交换 A[1] 和 A[i]
		tmp = A[1];
		A[1] = A[i];
		A[i] = tmp;
 
		heapsize--;
		MAX_HEAPIFY(A, 1);
	}
}
 
int main()
{
	int A[11] = { 0, 5, 3, 2, 1, 4, 6, 9, 7, 8, 10 };
	//ok
	int n = sizeof(A) / sizeof(int) - 1;
	heapsize = n;
 
	HEAPSORT(A);
 
	for (int i = 1; i &lt;= n; i++)
		printf(&quot;%d &quot;, A[i]);
 
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020-10-15]]></title>
        <id>https://aurora-wangq.github.io/post/2020-10-15/</id>
        <link href="https://aurora-wangq.github.io/post/2020-10-15/">
        </link>
        <updated>2020-10-15T03:30:30.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h3 id="t1树状数组1">T1<a href="https://www.luogu.com.cn/problem/P3374">树状数组1</a></h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;

int be[500004],tr[500004];
int n,m,opt,x,y;

int lowbit(int x) {

    return x&amp;(-x);
}

void update(int pos,int w) {

    while(pos&lt;=n) {

        tr[pos]+=w;
        pos+=lowbit(pos);
    }
} 

int fsum(int pos) {

    int ans=0;

    while(pos&gt;0) {

        ans+=tr[pos];
        pos-=lowbit(pos);
    }

    return ans;
}

int main() {

    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

    for(int i=1;i&lt;=n;i++) {

        scanf(&quot;%d&quot;,&amp;be[i]);
//cout&lt;&lt;&quot;21d12d&quot;&lt;&lt;endl;
        update(i,be[i]);
    }

    for(int i=1;i&lt;=m;i++) {

        scanf(&quot;%d&quot;,&amp;opt);

        if(opt==1) {

            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);

            update(x,y);
        }

        else {

            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);

            printf(&quot;%d\n&quot;,fsum(y)-fsum(x-1));
        }
    }


    return 0;
}
</code></pre>
<h3 id="t2树状数组2">T2<a href="https://www.luogu.com.cn/problem/P3368">树状数组2</a></h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;

int n,m,opt,x,y;
long long k,tr[500001],zc;

int lowbit(int a) {

    return a&amp;(-a);
}

void updata(int pos,long long w) {

    while(pos&lt;=n) {

        tr[pos]+=w;

        pos+=lowbit(pos);
    }
}

long long fsum(int x) {

    long long ans=0;

    while(x&gt;0) {

        ans+=tr[x];

        x-=lowbit(x);
    }

    return ans;
}

int main() {

    long long now=0;

    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

    for(int i=1;i&lt;=n;i++) {

        scanf(&quot;%lld&quot;,&amp;zc);
        updata(i,zc-now);
        now=zc;
    }

    for(int i=1;i&lt;=m;i++) {

        scanf(&quot;%d&quot;,&amp;opt);

        if(opt==1) {

            scanf(&quot;%d%d%lld&quot;,&amp;x,&amp;y,&amp;k);

            updata(x,k);
            updata(y+1,-k);
        }

        else {

            scanf(&quot;%d&quot;,&amp;x);

            printf(&quot;%lld\n&quot;,fsum(x));
        } 
    }
    return 0;
}
</code></pre>
<p><strong>需要用到差分数组，顺便学习了一下</strong></p>
<p><strong>附:</strong> 模板：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;

int be[500004],tr[500004];
int n,m,opt,x,y;

int lowbit(int x) {

    return x&amp;(-x);
}

void update(int pos,int w) {

    while(pos&lt;=n) {

        tr[pos]+=w;
        pos+=lowbit(pos);
    }
} 

int fsum(int pos) {

    int ans=0;

    while(pos&gt;0) {

        ans+=tr[pos];
        pos-=lowbit(pos);
    }

    return ans;
}

int main() {

    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

    for(int i=1;i&lt;=n;i++) {

        scanf(&quot;%d&quot;,&amp;be[i]);

        update(i,be[i]);
    }

    for(int i=1;i&lt;=m;i++) {

        scanf(&quot;%d&quot;,&amp;opt);

        if(opt==1) {

            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);

            update(x,y);
        }

        else {

            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);

            printf(&quot;%d\n&quot;,fsum(y)-fsum(x-1));
        }
    }


    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020-10-14]]></title>
        <id>https://aurora-wangq.github.io/post/2020-10-14/</id>
        <link href="https://aurora-wangq.github.io/post/2020-10-14/">
        </link>
        <updated>2020-10-14T03:32:15.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h3 id="t1瑞瑞的木板">T1<a href="https://www.luogu.com.cn/problem/P1334">瑞瑞的木板</a></h3>
<p><strong>可以手写小根堆</strong></p>
<pre><code class="language-cpp">int n,xl[10007];
int ans,mina,minb;

void init()  {

    scanf(&quot;%d&quot;,&amp;n);

    for(int i=1;i&lt;=n:i++)
        scanf(&quot;%d&quot;,&amp;xl[i]);
}

void exchange(int a,int b) {

    int tmp;
    tmp=a;
    a=b;
    b=tmp;
}

void mintop(int xl[],int root) {

    int l=root*2;
    int r=root*2+1;
    int small;

    if(xl[l]&lt;xl[root]&amp;&amp;l&lt;=n)
        small=l;

    else small=root;

    if(xl[r]&lt;xl[root]&amp;&amp;r&lt;=n)
        small=r;

    else small=root;

    if(small!=root) {

        exchange(xl[small],xl[root]);

        mintop(xl,small);
    }
}

void build(int xl[]) {

    for(int i=n/2;i&gt;=12;i++)
        mintop(xl,i);
}
</code></pre>
<p><strong>或者直接STL</strong></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;queue&gt;
#define ll long long
using namespace std;

int n,x;
ll ans;

priority_queue&lt;int , vector&lt;int&gt; , greater&lt;int&gt; &gt; dui;

int main() {

    scanf(&quot;%d&quot;,&amp;n);

    for(int i=1;i&lt;=n;i++) {

        scanf(&quot;%d&quot;,&amp;x);

        dui.push(x);
    }

    for(int i=1;i&lt;=n-1;i++) {

        int a=dui.top();
        dui.pop();
        int b=dui.top();
        dui.pop();
        ans+=a+b;
        dui.push(a+b);
    }

    printf(&quot;%lld&quot;,ans);

    return 0;
}
</code></pre>
<p><strong>大根堆</strong></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;

int heapsize;

void maxh(int a[],int i)
{

    int l=2*i;
    int r=2*i+1;
    int largest;

    if(l&lt;=heapsize&amp;&amp;a[l]&gt;a[i])
        largest=l;

    else 
        largest=i;

    if(r&lt;=heapsize&amp;&amp;a[r]&gt;a[largest])
        largest=r;

    if(largest!=i) {

        int tmp=a[largest];
        a[largest]=a[i];
        a[i]=tmp;

        maxh(a,largest);
    }
}

void buildmaxh(int a[])
{

    int i;
    for(int i = (int)(heapsize/2);i&gt;=1;i--) {

        maxh(a,i);
        for(int j=1;j&lt;=10;j++)
            printf(&quot;%d &quot;,a[j]);
        printf(&quot;\n&quot;);
    }
}

void heapsort(int a[])
{

    buildmaxh(a);

    int i;
    int tmp;
    for(int i=heapsize;i&gt;=2;i--) 
    {

        tmp=a[1]; 
        a[1]=a[i];
        a[i]=tmp;

        heapsize--;
        maxh(a,1);
    }    
}

int main() {

    int a[11] = { 0, 5, 3, 2, 1, 4, 6, 9, 7, 8, 10 };

    int n = sizeof(a) / sizeof(int) - 1;

    heapsize = n;

    heapsort(a);

    for(int i=1;i&lt;=n;i++)
        printf(&quot;%d &quot;,a[i]);
    return 0;
}
</code></pre>
<h3 id="t2中位数">T2<a href="https://www.luogu.com.cn/problem/P1168">中位数</a></h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;

const int maxn=1e5+7;
int bit[maxn];
int a[maxn],b[maxn];
int n,all;

inline int lowbit(int x)
{
    return x&amp;-x;
}

inline void add(int weizhi,int x)
{

    for(int i=weizhi;i&lt;=all;i+=lowbit(i))
    bit[i]+=x;
}

int find(int k)
{

    int ans=0,now=0;

    for(int i=20;i&gt;=0;i--) {

        ans+=(1&lt;&lt;i);             
        if(ans&gt;all||now+bit[ans]&gt;=k)ans-=(1&lt;&lt;i);
        else now+=bit[ans]; 
    }

    return ans+1;
}

int main()
{
    scanf(&quot;%d&quot;,&amp;n);

    for(int i=1;i&lt;=n;i++) {

        scanf(&quot;%d&quot;,&amp;a[++all]);
        b[all]=a[all];
    }

    sort(a+1,a+1+n);

    for(int i=1;i&lt;=n;i++)
        b[i]=lower_bound(a+1,a+1+all,b[i])-a;

    for(int i=1;i&lt;=n;i++) {

        add(b[i],1);
        if(i&amp;1)printf(&quot;%d\n&quot;,a[find((i+1)&gt;&gt;1)]);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020-9-27]]></title>
        <id>https://aurora-wangq.github.io/post/2020-9-27/</id>
        <link href="https://aurora-wangq.github.io/post/2020-9-27/">
        </link>
        <updated>2020-09-27T03:33:56.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h3 id="t15倍经验日">T1<a href="https://www.luogu.com.cn/problem/P1802">5倍经验日</a></h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#define ll long long
using namespace std;

ll n , v , lose[1002] , win[1002] , c[1002] , f[1002]; 

int main() {

    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;v);

    for(int i=1;i&lt;=n;i++) {

        scanf(&quot;%lld%lld%lld&quot;,&amp;lose[i],&amp;win[i],&amp;c[i]);
        // win[i]*=5;
        // lose[i]*=5;
    }


       for (int i=1;i&lt;=n;i++){
            for (int j=v;j&gt;=c[i];j--){
                f[j]=max(f[j]+lose[i],f[j-c[i]]+win[i]);
            }
            for (int j=c[i]-1;j&gt;=0;j--){
                f[j]+=lose[i];
            } 
        }

    printf(&quot;%lld&quot;,5*f[v]);

    return 0;
}
</code></pre>
<h3 id="t2装箱">T2<a href="https://www.luogu.com.cn/problem/P1049">装箱</a></h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;

int cap , n , v[20004];  
int f[20004];

int main() {

    scanf(&quot;%d&quot;,&amp;cap);
    scanf(&quot;%d&quot;,&amp;n);

    for(int i=1;i&lt;=n;i++) {

        scanf(&quot;%d&quot;,&amp;v[i]);
    }

    for(int i=1;i&lt;=n;i++) {

        for(int j=cap;j&gt;=v[i];j--) {

            if(j&gt;=v[i])
            f[j]=max(f[j],f[j-v[i]]+v[i]);
        }
    }

    printf(&quot;%d&quot;,cap-f[cap]);
    return 0;
}
</code></pre>
<h3 id="t2开心的金明">T2<a href="https://www.luogu.com.cn/problem/P1060">开心的金明</a></h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;

int n,m;
int v[30004],p[30004],f[30004];

using namespace std;
int main() {

    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

    for(int i = 1;i&lt;=m;i ++) {

        scanf(&quot;%d%d&quot;,&amp;v[i],&amp;p[i]);
        p[i]*=v[i];
    }


    for(int i = 1;i&lt;=m;i ++) {

        for(int j = n;j&gt;=v[i];j --) {

            if(j&gt;=v[i] ) {

                f[j]=max(f[j],f[j-v[i]]+p[i]);
            }
        }
    }

    printf(&quot;%d&quot;,f[n]);
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>